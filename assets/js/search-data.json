{
  
    
        "post0": {
            "title": "(2주차) 9월9일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/4) Path 설명 . - (2/4) 이미지 크롤링 . - (3/4) 모형학습 및 결과분석 . - (4/4) 테스트 . import . from fastai.data.all import * from fastai.vision.all import * . Path . - 기능: 현재폴더, 혹은 그 하위폴더들에 속한 파일의 목록을 볼 수 있다. . path=Path() # Path클래스에서 인스턴스생성 . (path/&#39;ghtop_images&#39;).ls() . (#2) [Path(&#39;ghtop_images/token.png&#39;),Path(&#39;ghtop_images/sparknb.gif&#39;)] . - Path(...)에서 ...에 무엇을 넣느냐에 따라 원하는 경로를 설정할 수 있다. . path=Path(&#39;/home&#39;) . path.ls() . (#1) [Path(&#39;/home/cgb4&#39;)] . - 폴더를 만들수 있다. . path=Path() . (path/&#39;asdf&#39;).mkdir() . (path/&#39;asdf&#39;).ls() . (#0) [] . - 이미 폴더가 존재할 때는 아래와 같이 에러가 발생 . (path/&#39;asdf&#39;).mkdir() . FileExistsError Traceback (most recent call last) /tmp/ipykernel_258436/283275367.py in &lt;module&gt; -&gt; 1 (path/&#39;asdf&#39;).mkdir() ~/anaconda3/envs/bda2021/lib/python3.8/pathlib.py in mkdir(self, mode, parents, exist_ok) 1286 self._raise_closed() 1287 try: -&gt; 1288 self._accessor.mkdir(self, mode) 1289 except FileNotFoundError: 1290 if not parents or self.parent == self: FileExistsError: [Errno 17] File exists: &#39;asdf&#39; . (path/&#39;asdf&#39;).mkdir(exist_ok=True) . - 생성한 폴더를 지우는 방법 . (path/&#39;asdf&#39;).rmdir() . &#51060;&#48120;&#51648; &#53356;&#47204;&#47553; . - 이미지 크롤링은 (1) 검색 (2) 이미지 주소를 찾음 (3) 해당주소로 이동하여 저장하는 과정을 반복하면 된다. . - 교재: 빙을 이용하여 이미지 크롤링 . 단점: 애져에 가입, 완전무료가 아님 (학생에게 1년간 무료) | . - 다른방법: 덕덕고를 이용한 이미지 크롤링 . ref: https://github.com/fastai/fastbook/blob/master/utils.py | . def search_images_ddg(key,max_n=200): &quot;&quot;&quot;Search for &#39;key&#39; with DuckDuckGo and return a unique urls of &#39;max_n&#39; images (Adopted from https://github.com/deepanprabhu/duckduckgo-images-api) &quot;&quot;&quot; url = &#39;https://duckduckgo.com/&#39; params = {&#39;q&#39;:key} res = requests.post(url,data=params) searchObj = re.search(r&#39;vqd=([ d-]+) &amp;&#39;,res.text) if not searchObj: print(&#39;Token Parsing Failed !&#39;); return requestUrl = url + &#39;i.js&#39; headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:71.0) Gecko/20100101 Firefox/71.0&#39;} params = ((&#39;l&#39;,&#39;us-en&#39;),(&#39;o&#39;,&#39;json&#39;),(&#39;q&#39;,key),(&#39;vqd&#39;,searchObj.group(1)),(&#39;f&#39;,&#39;,,,&#39;),(&#39;p&#39;,&#39;1&#39;),(&#39;v7exp&#39;,&#39;a&#39;)) urls = [] while True: try: res = requests.get(requestUrl,headers=headers,params=params) data = json.loads(res.text) for obj in data[&#39;results&#39;]: urls.append(obj[&#39;image&#39;]) max_n = max_n - 1 if max_n &lt; 1: return L(set(urls)) # dedupe if &#39;next&#39; not in data: return L(set(urls)) requestUrl = url + data[&#39;next&#39;] except: pass . - search_images_ddg(검색어)를 이용하여 검색어에 해당하는 url을 얻는다. . search_images_ddg(&#39;hynn&#39;,max_n=5) . (#5) [&#39;https://yt3.ggpht.com/a/AGF-l7_1jF579BUaWHBEpY95iZAb0WI2SC4vykeo3A=s900-c-k-c0xffffffff-no-rj-mo&#39;,&#39;http://talkimg.imbc.com/TVianUpload/tvian/TViews/image/2020/03/21/GRMTjLNM9a88637203974033409433.jpg&#39;,&#39;https://images.genius.com/a37e8f087886e8a9f1f1d4d4d02aba44.960x960x1.jpg&#39;,&#39;https://www.nautiljon.com/images/people/01/59/hynn_99095.jpg?0&#39;,&#39;https://lastfm.freetls.fastly.net/i/u/770x0/f6744fc617da497938bf0560c82fe0d2.jpg#f6744fc617da497938bf0560c82fe0d2&#39;] . - download_images(저장하고싶은폴더위치, url의리스트)를 이용하여 url에 해당하는 이미지를 저장하고 싶은 폴더에 저장. . path=Path() . path.ls() . (#14) [Path(&#39;2021-09-06-cat2.jpeg&#39;),Path(&#39;2021-09-06-hani03.jpg&#39;),Path(&#39;2021-09-06-hani01.jpeg&#39;),Path(&#39;ghtop_images&#39;),Path(&#39;2021-09-07-(1주차) 9월7일.ipynb&#39;),Path(&#39;Untitled.ipynb&#39;),Path(&#39;2021-08-17-(A1) 깃허브와 fastpages를 이용하여 블로그 개설하기.ipynb&#39;),Path(&#39;.ipynb_checkpoints&#39;),Path(&#39;2021-09-02-(1주차) 9월2일.ipynb&#39;),Path(&#39;2021-09-06-cat1.png&#39;)...] . download_images(path,urls=search_images_ddg(&#39;hynn&#39;,max_n=5)) . 현재 working dir에 5개의 이미지가 저장된다. | . keywords = &#39;hynn&#39;, &#39;iu&#39; path=Path(&#39;singer&#39;) . if not path.exists(): # 현재폴더에 singer라는 폴더가 있는지 체크 path.mkdir() # 현재폴더에 singer라는 폴더가 만들어짐 for keyword in keywords: # keyword=&#39;hynn&#39;, keyword=&#39;iu&#39; 일때 아래내용을 반복 lastpath=path/keyword # ./singer/hynn or ./singer/iu lastpath.mkdir(exist_ok=True) # make ./singer/hynn or ./singer/iu urls=search_images_ddg(keyword) # &#39;hynn&#39; 검색어로 url들의 리스트를 얻음 download_images(lastpath,urls=urls) # 그 url에 해당하는 이미지들을 ./singer/hynn or ./singer/iu 에 저장 . Cleaning Data . - 탐색기로 파일들을 살펴보니 조금 이상한 확장자도 있음. . - 조금 이상해보이는 확장자도 열리기는 함. . PILImage.create(&#39;./singer/iu/00000006.jpg:large&#39;) . verify_images(get_image_files(path)) . (#4) [Path(&#39;singer/iu/00000041.jpg&#39;),Path(&#39;singer/iu/00000029.jpg&#39;),Path(&#39;singer/iu/00000125.jpg&#39;),Path(&#39;singer/hynn/00000077.png&#39;)] . - 위에 해당하는 이미지를 수동으로 지워줌. . - csv을 받았으면 df를 만들어야 하듯이, 이미지 파일들을 받았으면 dls를 만들어야 fastai가 지원하는 함수로 분석하기 좋다. . dls = ImageDataLoaders.from_folder( path, train=&#39;singer&#39;, valid_pct=0.2, item_tfms=Resize(224)) . dls.show_batch(max_n=16) . - 모형을 만들고 학습을 시키자. . learn=cnn_learner(dls,resnet34,metrics=error_rate) learn.fine_tune(7) . epoch train_loss valid_loss error_rate time . 0 | 1.069038 | 0.753938 | 0.264706 | 00:04 | . epoch train_loss valid_loss error_rate time . 0 | 0.638990 | 0.531955 | 0.220588 | 00:04 | . 1 | 0.498534 | 0.338006 | 0.147059 | 00:04 | . 2 | 0.392531 | 0.268666 | 0.132353 | 00:04 | . 3 | 0.313377 | 0.214198 | 0.102941 | 00:04 | . 4 | 0.262075 | 0.227022 | 0.088235 | 00:04 | . 5 | 0.216234 | 0.228273 | 0.088235 | 00:04 | . 6 | 0.192656 | 0.218852 | 0.088235 | 00:04 | . learn.show_results(max_n=16) . &#50724;&#45813;&#48516;&#49437; . interp = Interpretation.from_learner(learn) interp.plot_top_losses(16) . - 수동으로 특정 observation에 대한 예측결과를 확인하여 보자. . dls.train_ds . (#272) [(PILImage mode=RGB size=960x960, TensorCategory(1)),(PILImage mode=RGB size=540x793, TensorCategory(1)),(PILImage mode=RGB size=800x1200, TensorCategory(1)),(PILImage mode=RGB size=720x960, TensorCategory(1)),(PILImage mode=RGB size=500x500, TensorCategory(0)),(PILImage mode=RGB size=1418x2000, TensorCategory(1)),(PILImage mode=RGB size=1920x1280, TensorCategory(1)),(PILImage mode=RGB size=480x360, TensorCategory(0)),(PILImage mode=RGB size=630x1045, TensorCategory(0)),(PILImage mode=RGB size=799x1200, TensorCategory(1))...] . training set | . dls.train_ds[0] . (PILImage mode=RGB size=960x960, TensorCategory(1)) . dls.train_ds[0] 가 의미하는 것은 첫번쨰 observation을 의미함. 즉 $(x_1,y_1)$ | $x_1=$PILImage mode=RGB size=960x960 | $y_1=$TensorCategory(1) | . dls.train_ds[210][0] . $x_{211}$=위의 이미지 | . dls.train_ds[210][1] . TensorCategory(0) . $y_{211}=$TensorCategory(0) | . x210=dls.train_ds[210][0] . learn.predict(x210) . (&#39;hynn&#39;, tensor(0), tensor([0.8893, 0.1107])) . Test . path = Path() . if not (path/&#39;test&#39;).exists(): (path/&#39;test&#39;).mkdir() . urls=search_images_ddg(&#39;hynn 박혜원&#39;,max_n=20) download_images(path/&#39;test&#39;,urls=urls) testset=get_image_files(path/&#39;test&#39;) testset . (#20) [Path(&#39;test/00000010.jpg&#39;),Path(&#39;test/00000005.jpg&#39;),Path(&#39;test/00000013.jpg&#39;),Path(&#39;test/00000011.jpg&#39;),Path(&#39;test/00000003.jpg&#39;),Path(&#39;test/00000000.jpg&#39;),Path(&#39;test/00000015.png&#39;),Path(&#39;test/00000004.jpg&#39;),Path(&#39;test/00000012.jpg&#39;),Path(&#39;test/00000006.jpg&#39;)...] . for i in range(len(testset)): print(learn.predict(PILImage.create(testset[i]))) . (&#39;hynn&#39;, tensor(0), tensor([1.0000e+00, 1.5190e-06])) . (&#39;hynn&#39;, tensor(0), tensor([0.9516, 0.0484])) . (&#39;hynn&#39;, tensor(0), tensor([0.9904, 0.0096])) . (&#39;hynn&#39;, tensor(0), tensor([9.9952e-01, 4.7845e-04])) . (&#39;hynn&#39;, tensor(0), tensor([0.9990, 0.0010])) . (&#39;hynn&#39;, tensor(0), tensor([0.9983, 0.0017])) . (&#39;hynn&#39;, tensor(0), tensor([0.9923, 0.0077])) . (&#39;iu&#39;, tensor(1), tensor([0.1120, 0.8880])) . (&#39;hynn&#39;, tensor(0), tensor([0.9949, 0.0051])) . (&#39;hynn&#39;, tensor(0), tensor([0.9982, 0.0018])) . (&#39;hynn&#39;, tensor(0), tensor([0.9940, 0.0060])) . (&#39;hynn&#39;, tensor(0), tensor([1.0000e+00, 8.8760e-07])) . (&#39;hynn&#39;, tensor(0), tensor([0.9963, 0.0037])) . (&#39;hynn&#39;, tensor(0), tensor([9.9975e-01, 2.5230e-04])) . (&#39;hynn&#39;, tensor(0), tensor([0.7672, 0.2328])) . (&#39;hynn&#39;, tensor(0), tensor([9.9982e-01, 1.8401e-04])) . (&#39;hynn&#39;, tensor(0), tensor([1.0000e+00, 3.9835e-06])) . (&#39;hynn&#39;, tensor(0), tensor([1.0000e+00, 6.5406e-07])) . (&#39;hynn&#39;, tensor(0), tensor([0.9253, 0.0747])) . (&#39;iu&#39;, tensor(1), tensor([0.1957, 0.8043])) . 결과를 보니까 hynn이 많음 $ to$ 어느정도 맞추는것 같긴하다. | . PILImage.create(testset[7]) . 실제로는 박혜원인데 아이유로 예측한 사진 | . path = Path() . if not (path/&#39;test2&#39;).exists(): (path/&#39;test2&#39;).mkdir() . urls=search_images_ddg(&#39;iu 아이유&#39;,max_n=20) download_images(path/&#39;test2&#39;,urls=urls) testset=get_image_files(path/&#39;test2&#39;) testset . (#20) [Path(&#39;test2/00000010.jpg&#39;),Path(&#39;test2/00000005.jpg&#39;),Path(&#39;test2/00000013.jpg&#39;),Path(&#39;test2/00000011.jpg&#39;),Path(&#39;test2/00000003.jpg&#39;),Path(&#39;test2/00000000.jpg&#39;),Path(&#39;test2/00000004.jpg&#39;),Path(&#39;test2/00000016.jpg&#39;),Path(&#39;test2/00000009.jpeg&#39;),Path(&#39;test2/00000012.jpg&#39;)...] . for i in range(len(testset)): print(learn.predict(PILImage.create(testset[i]))) . (&#39;iu&#39;, tensor(1), tensor([0.0051, 0.9949])) . (&#39;iu&#39;, tensor(1), tensor([8.7392e-06, 9.9999e-01])) . (&#39;iu&#39;, tensor(1), tensor([0.0895, 0.9105])) . (&#39;iu&#39;, tensor(1), tensor([0.0011, 0.9989])) . (&#39;iu&#39;, tensor(1), tensor([1.0321e-05, 9.9999e-01])) . (&#39;iu&#39;, tensor(1), tensor([0.0211, 0.9789])) . (&#39;iu&#39;, tensor(1), tensor([4.9877e-05, 9.9995e-01])) . (&#39;iu&#39;, tensor(1), tensor([0.0031, 0.9969])) . (&#39;iu&#39;, tensor(1), tensor([0.0011, 0.9989])) . (&#39;iu&#39;, tensor(1), tensor([1.5381e-05, 9.9998e-01])) . (&#39;iu&#39;, tensor(1), tensor([7.1447e-05, 9.9993e-01])) . (&#39;iu&#39;, tensor(1), tensor([1.3296e-04, 9.9987e-01])) . (&#39;hynn&#39;, tensor(0), tensor([0.9982, 0.0018])) . (&#39;iu&#39;, tensor(1), tensor([2.5169e-05, 9.9997e-01])) . (&#39;iu&#39;, tensor(1), tensor([1.2726e-05, 9.9999e-01])) . (&#39;iu&#39;, tensor(1), tensor([7.9650e-05, 9.9992e-01])) . (&#39;iu&#39;, tensor(1), tensor([3.0283e-04, 9.9970e-01])) . (&#39;iu&#39;, tensor(1), tensor([6.8668e-05, 9.9993e-01])) . (&#39;iu&#39;, tensor(1), tensor([0.0034, 0.9966])) . (&#39;iu&#39;, tensor(1), tensor([0.0052, 0.9948])) . 결과를 보니 아이유 역시 잘 맞추는 듯 보인다. | . - 정확률이 아쉽긴 하지만 어느정도 유의미한 결과를 얻었다. . &#49689;&#51228; . - 원하는 검색어로 이미지를 모은 뒤 결과를 제출 .",
            "url": "https://guebin.github.io/2021BDA/2021/09/09/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%949%EC%9D%BC.html",
            "relUrl": "/2021/09/09/(2%EC%A3%BC%EC%B0%A8)-9%EC%9B%949%EC%9D%BC.html",
            "date": " • Sep 9, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "(1주차) 9월7일",
            "content": "&#44053;&#51032;&#50689;&#49345; . . - (1/6): 아나콘다 가상환경 만들기, 파이토치 설치, 주피터랩 설치, conda install 과 pip install 의 차이 . - (2/6): 이미지 분석을 위한 데이터셋 준비 및 정리 . - (3/6): 학습 및 예측 . - (4/6): 코랩설명 + 깃허브/블로그 (뒷부분은 화면전환 오류로 설명이 부실함) . - (5/6): 코랩설명 + 깃허브/블로그 . - (6/6): 우리강아지 이미지를 활용한 예측, 과제설명 . import . from fastai.vision.all import * . &#45936;&#51060;&#53552;&#51200;&#51109;, &#45936;&#51060;&#53552;&#47196;&#45908;&#49828; &#49373;&#49457;&#54980; dls&#47196; &#51200;&#51109; . path=untar_data(URLs.PETS)/&#39;images&#39; . files=get_image_files(path) # 이미지파일들의 이름을 모두 복붙하여 리스트를 만든뒤에 files.txt로 저장하는 과정으로 비유할 수 있음 . files[2] # txt 파일의 3번째 목록 . Path(&#39;/home/cgb4/.fastai/data/oxford-iiit-pet/images/leonberger_5.jpg&#39;) . def label_func(f): if f[0].isupper(): return &#39;cat&#39; else: return &#39;dog&#39; . label_func(&#39;asdf&#39;) . &#39;dog&#39; . dls=ImageDataLoaders.from_name_func(path,files,label_func,item_tfms=Resize(224)) . dls.show_batch(max_n=16) . &#54617;&#49845; . learn=cnn_learner(dls,resnet34,metrics=error_rate) . Downloading: &#34;https://download.pytorch.org/models/resnet34-b627a593.pth&#34; to C: Users cgb/.cache torch hub checkpoints resnet34-b627a593.pth . ImportError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_29964/2234347239.py in &lt;module&gt; -&gt; 1 learn=cnn_learner(dls,resnet34,metrics=error_rate) ~ anaconda3 envs bda2021 lib site-packages fastai vision learner.py in cnn_learner(dls, arch, normalize, n_out, pretrained, config, loss_func, opt_func, lr, splitter, cbs, metrics, path, model_dir, wd, wd_bn_bias, train_bn, moms, **kwargs) 177 if n_out is None: n_out = get_c(dls) 178 assert n_out, &#34;`n_out` is not defined, and could not be inferred from data, set `dls.c` or pass `n_out`&#34; --&gt; 179 model = create_cnn_model(arch, n_out, pretrained=pretrained, **kwargs) 180 181 splitter=ifnone(splitter, meta[&#39;split&#39;]) ~ anaconda3 envs bda2021 lib site-packages fastai vision learner.py in create_cnn_model(arch, n_out, pretrained, cut, n_in, init, custom_head, concat_pool, **kwargs) 141 &#34;Create custom convnet architecture&#34; 142 meta = model_meta.get(arch, _default_meta) --&gt; 143 body = create_body(arch, n_in, pretrained, ifnone(cut, meta[&#39;cut&#39;])) 144 if custom_head is None: 145 nf = num_features_model(nn.Sequential(*body.children())) ~ anaconda3 envs bda2021 lib site-packages fastai vision learner.py in create_body(arch, n_in, pretrained, cut) 63 def create_body(arch, n_in=3, pretrained=True, cut=None): 64 &#34;Cut off the body of a typically pretrained `arch` as determined by `cut`&#34; &gt; 65 model = arch(pretrained=pretrained) 66 _update_first_layer(model, n_in, pretrained) 67 #cut = ifnone(cut, cnn_config(arch)[&#39;cut&#39;]) ~ anaconda3 envs bda2021 lib site-packages torchvision models resnet.py in resnet34(pretrained, progress, **kwargs) 286 progress (bool): If True, displays a progress bar of the download to stderr 287 &#34;&#34;&#34; --&gt; 288 return _resnet(&#39;resnet34&#39;, BasicBlock, [3, 4, 6, 3], pretrained, progress, 289 **kwargs) 290 ~ anaconda3 envs bda2021 lib site-packages torchvision models resnet.py in _resnet(arch, block, layers, pretrained, progress, **kwargs) 260 model = ResNet(block, layers, **kwargs) 261 if pretrained: --&gt; 262 state_dict = load_state_dict_from_url(model_urls[arch], 263 progress=progress) 264 model.load_state_dict(state_dict) ~ anaconda3 envs bda2021 lib site-packages torch hub.py in load_state_dict_from_url(url, model_dir, map_location, progress, check_hash, file_name) 551 r = HASH_REGEX.search(filename) # r is Optional[Match[str]] 552 hash_prefix = r.group(1) if r else None --&gt; 553 download_url_to_file(url, cached_file, hash_prefix, progress=progress) 554 555 if _is_legacy_zip_format(cached_file): ~ anaconda3 envs bda2021 lib site-packages torch hub.py in download_url_to_file(url, dst, hash_prefix, progress) 436 if hash_prefix is not None: 437 sha256 = hashlib.sha256() --&gt; 438 with tqdm(total=file_size, disable=not progress, 439 unit=&#39;B&#39;, unit_scale=True, unit_divisor=1024) as pbar: 440 while True: ~ anaconda3 envs bda2021 lib site-packages tqdm notebook.py in __init__(self, *args, **kwargs) 240 unit_scale = 1 if self.unit_scale is True else self.unit_scale or 1 241 total = self.total * unit_scale if self.total else self.total --&gt; 242 self.container = self.status_printer(self.fp, total, self.desc, self.ncols) 243 self.container.pbar = proxy(self) 244 self.displayed = False ~ anaconda3 envs bda2021 lib site-packages tqdm notebook.py in status_printer(_, total, desc, ncols) 113 # Prepare IPython progress bar 114 if IProgress is None: # #187 #451 #558 #872 --&gt; 115 raise ImportError( 116 &#34;IProgress not found. Please update jupyter and ipywidgets.&#34; 117 &#34; See https://ipywidgets.readthedocs.io/en/stable&#34; ImportError: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html . - 에러를 해결하기 위해서는 아래를 설치하면 된다. . !conda install -c conda-forge jupyterlab_widgets -y !conda install -c conda-forge ipywidgets -y !conda install -c conda-forge nodejs -y . - 위를 설치하고 커널을 재시작하면 정상적으로 모형이 만들어진다. . learn=cnn_learner(dls,resnet34,metrics=error_rate) . /home/cgb4/anaconda3/envs/bda2021/lib/python3.8/site-packages/torch/nn/functional.py:718: UserWarning: Named tensors and all their associated APIs are an experimental feature and subject to change. Please do not use them for anything important until they are released as stable. (Triggered internally at /tmp/pip-req-build-pma2oi4d/c10/core/TensorImpl.h:1156.) return torch.max_pool2d(input, kernel_size, stride, padding, dilation, ceil_mode) . learn.fine_tune(1) . epoch train_loss valid_loss error_rate time . 0 | 0.148441 | 0.018828 | 0.006766 | 00:12 | . epoch train_loss valid_loss error_rate time . 0 | 0.040593 | 0.014769 | 0.002706 | 00:11 | . &#50696;&#52769; . learn.predict(files[0]) . (&#39;dog&#39;, tensor(1), tensor([6.1421e-07, 1.0000e+00])) . learn.show_results() . &#50724;&#45813;&#48516;&#49437; . interp = Interpretation.from_learner(learn) . interp.plot_top_losses(16) . &#51652;&#51676; &#51096;&#46104;&#45716;&#44172; &#47582;&#45716;&#44148;&#44032;? . PILImage.create(&#39;2021-09-06-cat1.png&#39;) . learn.predict(PILImage.create(&#39;2021-09-06-cat1.png&#39;)) . (&#39;cat&#39;, tensor(0), tensor([1.0000e+00, 1.7844e-07])) . - 헷갈리는 고양이 사진인데 잘 구분한다. . PILImage.create(&#39;2021-09-06-cat2.jpeg&#39;) . learn.predict(PILImage.create(&#39;2021-09-06-cat2.jpeg&#39;)) . (&#39;cat&#39;, tensor(0), tensor([9.9984e-01, 1.6283e-04])) . PILImage.create(&#39;2021-09-06-hani01.jpeg&#39;) . learn.predict(PILImage.create(&#39;2021-09-06-hani01.jpeg&#39;)) . (&#39;dog&#39;, tensor(1), tensor([5.0984e-04, 9.9949e-01])) . PILImage.create(&#39;2021-09-06-hani02.jpeg&#39;) . learn.predict(PILImage.create(&#39;2021-09-06-hani02.jpeg&#39;)) . (&#39;dog&#39;, tensor(1), tensor([7.1694e-06, 9.9999e-01])) . PILImage.create(&#39;2021-09-06-hani03.jpg&#39;) . learn.predict(PILImage.create(&#39;2021-09-06-hani03.jpg&#39;)) . (&#39;dog&#39;, tensor(1), tensor([4.5399e-04, 9.9955e-01])) . &#45796;&#51020;&#49884;&#44036; . 이미지 크롤링 --&gt; 데이터셋트 --&gt; A,B 구분하는 모델 | . &#49689;&#51228; . 위의 사진들 이외에 사진들을 바탕으로 예측을 하는 모형구축. | 예측결과를 스샷으로 저장하여 제출 (이미지도 함께 스샷할것) | . &#49689;&#51228;&#52280;&#44256;&#51088;&#47308; . import PIL urls=&#39;https://t1.daumcdn.net/cfile/tistory/9925F03C5AD486B033&#39; urllib.request.urlretrieve(urls,&#39;temp.png&#39;) learn.predict(PILImage.create(&#39;temp.png&#39;)) . (&#39;dog&#39;, tensor(1), tensor([6.6117e-04, 9.9934e-01])) .",
            "url": "https://guebin.github.io/2021BDA/2021/09/07/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%947%EC%9D%BC.html",
            "relUrl": "/2021/09/07/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%947%EC%9D%BC.html",
            "date": " • Sep 7, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "(1주차) 9월2일",
            "content": "&#44053;&#51032;&#50689;&#49345; . - (1/3): 과목소개 . - (2/3): 카카오톡 채널 소개 . - (3/3): 텐서플로우-케라스 vs 파이토치-fastai, 과제안내 . . &#47112;&#54252;&#53944; . - 카카오톡 스샷제출 .",
            "url": "https://guebin.github.io/2021BDA/2021/09/02/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%942%EC%9D%BC.html",
            "relUrl": "/2021/09/02/(1%EC%A3%BC%EC%B0%A8)-9%EC%9B%942%EC%9D%BC.html",
            "date": " • Sep 2, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "(A1) 깃허브와 fastpages를 이용하여 블로그 개설하기",
            "content": "About this doc . - 본 포스트는 2021년 1학기 Python 입문 강의내용중 일부를 업로드 하였음. . - Github, fastpages를 사용하여 블로그를 개설하고 관리하는 방법에 대한 설명임. . .",
            "url": "https://guebin.github.io/2021BDA/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0.html",
            "relUrl": "/2021/08/17/(A1)-%EA%B9%83%ED%97%88%EB%B8%8C%EC%99%80-fastpages%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%EC%84%A4%ED%95%98%EA%B8%B0.html",
            "date": " • Aug 17, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "최규빈 . guebin@jbnu.ac.kr | 자연과학대학교 본관 205호 | 카카오톡 오픈채널 1 | . 2021년 2학기 종료후 폐쇄예정 &#8617; . |",
          "url": "https://guebin.github.io/2021BDA/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://guebin.github.io/2021BDA/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}